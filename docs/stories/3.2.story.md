# Story 3.2: Scoring and Statistics System - Brownfield Addition

## Status: In Progress

## Story

As a badminton player,
I want to track my performance and view comprehensive statistics,
So that I can improve my game and see my progress over time.

## Context Source

- Source Document: docs/prd.md (Phase 3 score recording and Phase 4 statistics requirements)
- Enhancement Type: Analytics and performance tracking feature
- Existing System Impact: Adds scoring data model and statistics layer to existing session system

## Acceptance Criteria

**Functional Requirements:**

1. **Score Recording**: Record 2-0 and 2-1 match results with automatic validation
2. **Permission-based Recording**: Players record their own matches, organizers can record any match
3. **Real-time Statistics**: Statistics update immediately after score submission
4. **Player Statistics**: Individual win/loss record, win rate, games played
5. **Ranking System**: Automatic ranking based on performance metrics
6. **Match History**: Complete history of all matches with detailed results
7. **Data Export**: Export personal statistics and match history
8. **Statistics Dashboard**: Visual dashboard showing key performance metrics

**Integration Requirements:**

9. **Existing Player Integration**: Statistics tied to existing player identities
10. **Session Integration**: Match results linked to specific sessions and pairings
11. **Real-time Updates**: Statistics update across all devices immediately
12. **Permission Integration**: Respects existing permission system for data access

**Quality Requirements:**

13. **Data Accuracy**: 100% accuracy in score recording and statistics calculation
14. **Performance**: Statistics queries return within 500ms
15. **Scalability**: System supports thousands of matches and players
16. **Backup**: All scoring data automatically backed up
17. **Audit Trail**: Complete history of all score changes and approvals

**Non-Functional Requirements:**

18. **Privacy**: Players control visibility of their statistics
19. **Usability**: Intuitive score recording interface
20. **Reliability**: 99.9% uptime for statistics access
21. **Internationalization**: Support for multiple scoring formats if needed
22. **Accessibility**: Statistics dashboard accessible to all users

## Dev Technical Guidance

### Existing System Context

Current system has player and session management from Epics 1-2. Existing patterns include data models, API endpoints, and real-time updates.

### Integration Approach

Add score and match models, create scoring API endpoints, build statistics calculation service, integrate with existing player and session models.

### Technical Constraints

- Must maintain data integrity for competitive fairness
- Real-time statistics updates required
- Permission controls mandatory for score recording
- Performance critical for good user experience

### Missing Information

- Statistics calculation algorithms
- Ranking system formula
- Data retention policies
- Export format specifications

### Tasks / Subtasks

- [ ] Task 1: Design scoring data models
  - [ ] Create Match model for individual games
  - [ ] Create Score model for detailed results
  - [ ] Add statistics fields to Player model
  - [ ] Update Prisma schema with relationships

- [ ] Task 2: Implement score recording API
  - [ ] Create POST /api/matches endpoint
  - [ ] Add score validation and permission checks
  - [ ] Implement organizer approval workflow
  - [ ] Add real-time statistics updates

- [ ] Task 3: Build score recording UI
  - [ ] Create ScoreRecordingScreen component
  - [ ] Add score input for 2-0/2-1 results
  - [ ] Implement permission-based UI controls
  - [ ] Add score validation and error handling

- [ ] Task 4: Develop statistics calculation service
  - [ ] Create StatisticsService class
  - [ ] Implement win rate and ranking calculations
  - [ ] Add performance metrics computation
  - [ ] Create statistics caching layer

- [ ] Task 5: Build statistics dashboard
  - [ ] Create StatisticsDashboard component
  - [ ] Add charts and graphs for key metrics
  - [ ] Implement filtering and date ranges
  - [ ] Add data export functionality

- [ ] Task 6: Add ranking system
  - [ ] Implement ranking algorithm
  - [ ] Add ranking updates after each match
  - [ ] Create ranking display components
  - [ ] Add ranking history tracking

- [ ] Task 7: Comprehensive testing and optimization
  - [ ] Unit tests for statistics calculations
  - [ ] Integration tests for score recording
  - [ ] Performance tests for large datasets
  - [ ] UI tests for statistics dashboard

## Testing

### Validation Steps

1. Record several match results as different players
2. Verify statistics update in real-time
3. Check permission controls for score recording
4. Test statistics dashboard with various filters
5. Export personal statistics
6. Verify ranking updates after matches
7. Test organizer approval workflow

### Test Scenarios

- Score recording with different permission levels
- Statistics calculation accuracy
- Real-time updates across devices
- Data export functionality
- Ranking system fairness
- Performance with large match history

## Dev Notes

### File Structure Impact

New files to be created:
- backend/src/models/Match.ts
- backend/src/models/Score.ts
- backend/src/services/statisticsService.ts
- backend/src/routes/matches.ts
- backend/src/routes/statistics.ts
- frontend/src/screens/ScoreRecordingScreen.tsx
- frontend/src/screens/StatisticsDashboard.tsx
- frontend/src/components/RankingList.tsx
- frontend/src/services/scoringApi.ts

Modified files:
- backend/prisma/schema.prisma
- backend/src/models/Player.ts
- backend/src/routes/players.ts
- frontend/src/navigation/AppNavigator.tsx
- frontend/src/contexts/SessionContext.tsx

### Data Models

```prisma
model Match {
  id          String   @id @default(cuid())
  sessionId   String
  player1Id   String
  player2Id   String
  winnerId    String
  scoreType   String   // "2-0" or "2-1"
  recordedBy  String
  recordedAt  DateTime @default(now())
  approvedBy  String?
  approvedAt  DateTime?

  session     Session  @relation(fields: [sessionId], references: [id])
  player1     Player   @relation("Player1Matches", fields: [player1Id], references: [id])
  player2     Player   @relation("Player2Matches", fields: [player2Id], references: [id])
  winner      Player   @relation("WinnerMatches", fields: [winnerId], references: [id])
  recorder    Player   @relation("RecorderMatches", fields: [recordedBy], references: [id])
  approver    Player?  @relation("ApproverMatches", fields: [approvedBy], references: [id])
}

model Player {
  // ... existing fields
  totalMatches    Int       @default(0)
  wins            Int       @default(0)
  losses          Int       @default(0)
  winRate         Float     @default(0)
  ranking         Int?
  rankingPoints   Int       @default(0)
  lastMatchDate   DateTime?

  // ... existing relations
  player1Matches  Match[]   @relation("Player1Matches")
  player2Matches  Match[]   @relation("Player2Matches")
  winnerMatches   Match[]   @relation("WinnerMatches")
  recorderMatches Match[]   @relation("RecorderMatches")
  approverMatches Match[]   @relation("ApproverMatches")
}
```

### API Contracts

Record Match:
```json
POST /api/matches
{
  "sessionId": "string",
  "player1Id": "string",
  "player2Id": "string",
  "winnerId": "string",
  "scoreType": "2-0" | "2-1"
}
```

Get Player Statistics:
```json
GET /api/players/{id}/statistics
{
  "totalMatches": 25,
  "wins": 18,
  "losses": 7,
  "winRate": 0.72,
  "ranking": 3,
  "rankingPoints": 1250,
  "recentMatches": [...]
}
```

### Statistics Calculations

**Win Rate:** wins / totalMatches
**Ranking Points:** Based on opponent strength and recency
**Ranking:** Position based on ranking points
**Performance Metrics:** Average points per game, consistency score

### Real-time Events

```typescript
// Match recorded
socket.emit('match_recorded', {
  matchId: string,
  sessionId: string,
  winnerId: string,
  statistics: object
});

// Statistics updated
socket.emit('statistics_updated', {
  playerId: string,
  newStatistics: object
});
```

## Definition of Done

- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (existing and new)
- [ ] Documentation updated if applicable

## Risk Assessment

**Minimal Risk Assessment:**

- **Primary Risk:** Statistics calculation errors could affect player experience
- **Mitigation:** Comprehensive testing of calculations, approval workflow for changes
- **Rollback:** Statistics features can be disabled, data can be recalculated

**Compatibility Verification:**

- [ ] No breaking changes to existing player data
- [ ] Statistics are additive (optional features)
- [ ] Performance impact acceptable
- [ ] Backward compatibility maintained