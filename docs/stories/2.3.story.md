# Story 2.3: Basic Pairing Algorithm - Brownfield Addition

## Status: Done

## Story

As a session organizer,
I want an automatic pairing system that creates fair gameplay combinations,
So that players are matched optimally based on participation and skill levels.

## Context Source

- Source Document: docs/prd.md (Phase 2 pairing management requirements)
- Enhancement Type: Gameplay optimization feature
- Existing System Impact: Adds intelligent pairing to existing session management

## Acceptance Criteria

**Functional Requirements:**

1. **Automatic Pairing**: System can generate pairings for 4-20 players automatically
2. **Fairness Algorithm**: Pairings consider player participation history and skill levels
3. **Manual Override**: Organizer can manually adjust any generated pairing
4. **Pairing Display**: Clear visualization of current pairings with player positions
5. **Pairing History**: Record of all pairings for session analysis
6. **Re-pairing**: Ability to generate new pairings while preserving fairness
7. **Pairing Validation**: System prevents invalid pairings (same player twice, etc.)

**Integration Requirements:**

8. **Player Status Integration**: Excludes resting and left players from pairings
9. **Real-time Updates**: Pairing changes reflected immediately across devices
10. **Permission Integration**: Only organizer can generate/modify pairings
11. **Session Integration**: Pairings tied to specific sessions and games

**Quality Requirements:**

12. **Algorithm Accuracy**: Pairings generated within 2 seconds for up to 20 players
13. **Fairness Metrics**: System provides fairness score for each pairing
14. **Error Handling**: Graceful handling of edge cases (odd players, skill imbalances)
15. **Test Coverage**: Unit tests for algorithm, integration tests for UI
16. **Performance**: Pairing operations don't impact session performance

**Non-Functional Requirements:**

17. **Usability**: Pairing interface intuitive for organizers
18. **Reliability**: Pairing algorithm produces valid results 100% of the time
19. **Scalability**: Algorithm scales to 20+ players without performance degradation
20. **Transparency**: Users can understand how pairings were determined

## Dev Technical Guidance

### Existing System Context

Current system has player and session management from Epic 1. Existing patterns include algorithmic processing and real-time updates.

### Integration Approach

Create pairing service with algorithm, add pairing API endpoints, integrate with session UI, update real-time events for pairing changes.

### Technical Constraints

- Must handle 4-20 players (even/odd numbers)
- Algorithm must be fast and deterministic
- Pairings must consider player status
- Manual overrides must be preserved

### Missing Information

- Exact pairing algorithm logic
- Skill level determination method
- Fairness scoring criteria
- UI layout for pairing display

### Tasks / Subtasks

- [ ] Task 1: Design pairing algorithm
  - [ ] Define fairness criteria and weights
  - [ ] Implement basic pairing logic
  - [ ] Add skill level considerations
  - [ ] Handle odd number of players

- [ ] Task 2: Create pairing service
  - [ ] Implement PairingService class
  - [ ] Add pairing generation methods
  - [ ] Include fairness scoring
  - [ ] Add manual override support

- [ ] Task 3: Implement pairing API
  - [ ] Create POST /api/sessions/{id}/pairings endpoint
  - [ ] Add GET /api/sessions/{id}/pairings for current pairings
  - [ ] Implement manual adjustment endpoints
  - [ ] Add pairing validation

- [ ] Task 4: Build pairing UI
  - [ ] Create PairingScreen component
  - [ ] Add pairing visualization
  - [ ] Implement drag-drop for manual adjustments
  - [ ] Add pairing controls (generate, save, reset)

- [ ] Task 5: Integrate with player status
  - [ ] Filter out resting/left players
  - [ ] Handle status changes during pairing
  - [ ] Update pairings when status changes
  - [ ] Preserve manual adjustments

- [ ] Task 6: Add real-time pairing updates
  - [ ] Emit pairing change events
  - [ ] Update UI across devices
  - [ ] Handle concurrent pairing modifications
  - [ ] Add pairing conflict resolution

- [ ] Task 7: Comprehensive testing
  - [ ] Unit tests for pairing algorithm
  - [ ] Integration tests for API endpoints
  - [ ] UI tests for pairing interface
  - [ ] Performance tests for large groups

## Testing

### Validation Steps

1. Create session with 6-8 players
2. Generate automatic pairing
3. Verify fairness of pairings
4. Manually adjust a pairing
5. Save and verify persistence
6. Test with odd number of players
7. Verify exclusion of resting players
8. Test real-time updates

### Test Scenarios

- Automatic pairing generation for even/odd players
- Manual pairing adjustments
- Fairness scoring accuracy
- Player status integration
- Real-time synchronization
- Edge cases (minimum players, skill imbalances)

## Dev Notes

### File Structure Impact

New files to be created:
- backend/src/services/pairingService.ts
- backend/src/algorithms/pairingAlgorithm.ts
- backend/src/routes/pairings.ts
- frontend/src/screens/PairingScreen.tsx
- frontend/src/components/PairingGrid.tsx
- frontend/src/services/pairingApi.ts

Modified files:
- backend/src/routes/sessions.ts
- frontend/src/navigation/AppNavigator.tsx
- frontend/src/contexts/SessionContext.tsx

### Pairing Algorithm Overview

**Input:**
- List of active players (excluding resting/left)
- Player skill levels (if available)
- Participation history
- Previous pairing data

**Algorithm Steps:**
1. Sort players by participation (least played first)
2. Group by skill level (if available)
3. Generate balanced pairs
4. Calculate fairness score
5. Handle odd players (create triples or rotate)

**Fairness Score:**
- Participation balance: 40%
- Skill level balance: 30%
- Previous pairing diversity: 30%

### API Contracts

Generate Pairings:
```json
POST /api/sessions/{id}/pairings
{
  "algorithm": "fair" | "random" | "skill_based"
}
```

Response:
```json
{
  "pairings": [
    {
      "court": 1,
      "players": [
        { "id": "p1", "name": "Alice", "position": "left" },
        { "id": "p2", "name": "Bob", "position": "right" }
      ]
    }
  ],
  "fairnessScore": 85,
  "generatedAt": "timestamp"
}
```

Manual Adjustment:
```json
PUT /api/sessions/{id}/pairings/{pairingId}
{
  "players": [
    { "id": "p1", "position": "left" },
    { "id": "p3", "position": "right" }
  ]
}
```

### UI Components

**PairingGrid Component:**
- Visual representation of courts and pairs
- Drag-and-drop for manual adjustments
- Color coding for fairness indicators
- Real-time updates

**PairingControls:**
- Generate new pairings button
- Algorithm selection dropdown
- Save/cancel changes
- Fairness score display

### Real-time Events

```typescript
// New pairings generated
socket.emit('pairings_updated', {
  sessionId: 'string',
  pairings: [...],
  fairnessScore: 85
});

// Manual adjustment made
socket.emit('pairing_adjusted', {
  sessionId: 'string',
  pairingId: 'string',
  changes: [...]
});
```

## Definition of Done

- [ ] Functional requirements met
- [ ] Integration requirements verified
- [ ] Existing functionality regression tested
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (existing and new)
- [ ] Documentation updated if applicable

## Risk Assessment

**Minimal Risk Assessment:**

- **Primary Risk:** Pairing algorithm could create unfair or invalid pairings
- **Mitigation:** Comprehensive testing, manual override capability
- **Rollback:** Pairing features can be hidden via UI flags

**Compatibility Verification:**

- [ ] No breaking changes to existing session data
- [ ] Algorithm runs efficiently on mobile devices
- [ ] UI gracefully handles pairing failures
- [ ] Real-time events are optional (backward compatible)